
@@@ Module: SimpleBUDP @@@

# Module: simple_budp.h
## Secure UDP Communication Library

@@@ Feature Overview @@@
The `simple_budp` library provides a high-level API for binary-safe, encrypted, and identity-verified UDP networking. 
It utilizes a slicing engine for large payloads (up to 64KB) and handles the $ BudpSession $ lifecycle, including automated handshakes, 256-bit Diffie-Hellman key exchange, and identity pinning.

-> Binary Safety Note: Data is no longer restricted by null terminators. The library uses explicit length headers (data_len) to ensure 0x00 bytes do not truncate packets during transmission or reassembly.

@@@ Core Lifecycle Functions @@@

| Function Definitions
|
| -- > void binit(const char* identity_seed)
|    | -- > Initializes the library and derives 256-bit local identity limbs from the $ seed $.
|    |
| -- > int bopen(int id, int port)
|    | -- > Opens a socket for a specific session ID.
|    | -- > Use $ port $ 0 for a random client port, or a specific number for a server.
|    |
| -- > void bconnect(int id, char* host, int port)
|    | -- > Initiates a connection sequence to a remote $ host $ and $ port $.
|    |
| -- > char* bupdate(int id)
|    | -- > The heart of the library; drains the socket and handles reassembly.
|    | -- > Returns && "CONNECTED" && on successful handshake.
|    | -- > Returns && "DEAD" && on heartbeat timeout.
|    | -- > Returns $ char* $ payload when a full message (or slice) is ready.
|    |
| -- > void bsend(int id, char* data)
|    | -- > Slices and sends $ data $. Now handles binary data safely via length-aware fragmentation.
|    |
| -- > void bclose(int id)
|    | -- > Closes the network socket and wipes the session state.

## Security & Mode Configuration
% Note: Encryption status is negotiated during the handshake flow %

| Manual Overrides
|
| -- > void UseE(int id)
|    | -- > Requests the use of encryption (256-bit DH exchange).
|    |
| -- > void NoE(int id)
|    | -- > Disables encryption for the session (Plaintext mode).
|    |
| -- > void bforceE(int id)
|    | -- > Strict Mode: Kills the connection if the peer does not support encryption.
|    |
| -- > void bforceNoE(int id)
|    | -- > Strict Mode: Kills the connection if the peer tries to use encryption.
|    |
| -- > void enableheartbeat(int id)
|    | -- > Activates the 10-second timeout logic to detect dropped peers.

## Identity Management
$$ High Priority $$
\\ Identity Pinning is handled automatically by the library based on the IP address.
\\

| Identity Functions
|
| -- > uint64_t bget_my_public_id(int id)
|    | -- > Returns the primary 64-bit component of your DH public key.
|    |
| -- > void breset(int id)
|    | -- > Clears current session logic without closing the underlying socket.

## Implementation Example
||
// Standard Setup
   binit("USER_SECRET_KEY");
   bopen(0, 8080);
   enableheartbeat(0);
   
   while(running) {
       char* msg = bupdate(0);
       if(msg) printf("Recv: %s\n", msg);
       b_sleep(1); // Polling interval (adjustable)
   }
||

$$$ Warning!! $$$
&& Handshake fails immediately if a pinned identity in ~/.local/BUDP/ mismatches the remote peer &&
^ This prevents Man-In-The-Middle (MITM) attacks.


---

@@@ Module: SimpleConflictsFixer @@@

# SimpleConflictsFixer Documentation
## Windows Header Namespace Sanitizer

@@@ Feature Overview @@@

The `SimpleConflictsFixer` is a specialized header designed to prevent naming collisions between the Windows API and modern C/C++ libraries or custom user code.
It specifically targets common function names that `windows.h` defines as macros, which often "pollute" the global namespace.

-> Platform Specific: This module only executes logic if $_WIN32$ is defined.
--> Target Version: Forces $_WIN32_WINNT$ to $0x0600$ (Windows Vista or higher).

| Collision Management
|
| -- > Temporary Macro Redefinition
|    | -- > $CloseWindow$ -> $WinCloseWindow$ 
|    | -- > $ShowCursor$ -> $WinShowCursor$ 
|    | -- > $Rectangle$ -> $WinRectangle$ 
|    | -- > $DrawText$ -> $WinDrawText$ 
|
| -- > Post-Include Cleanup
|    | -- > All temporary $Win$ macros are $#undef$ after headers are loaded.
|    | -- > Explicitly $#undef interface$ to prevent COM conflicts.

## Protected Headers
The following system headers are wrapped by this fixer to ensure they do not break external logic:

1.  $winsock2.h$ 
2.  $windows.h$ 
3.  $objbase.h$ 

$$ High Priority $$
\\ This header should be included BEFORE other QOL modules that utilize networking or graphics to ensure symbols like "Rectangle" remain available for custom use. \\


---

@@@ Module: SimpleFS @@@

# SimpleFS Documentation
## Platform-Independent File System Module

@@@ Feature Overview @@@

`SimpleFS` provides a high-level API for file manipulation, path normalization, and data extraction. 
It abstracts away the differences between Windows and POSIX path separators to ensure code portability.

-> Platform Paths: Automatically detects $ _WIN32 $ to set $ PATH_SEP $ ('\') and $ ALT_SEP $ ('/').
--> Normalizer: The internal $ _fs_normalize $ function automatically converts slashes to the system default.

| Conversion & Hashing Logic
|
| -- > $ char_to_int(ptr, len) $
|    | -- > Generates a 32-bit FNV-1a hash from a byte buffer.
|
| -- > $ char_to_float(ptr, len) $
|    | -- > Converts a hashed buffer into a float between 0.0 and 1.0.

## Core File Operations
% Efficiency: All path-based functions use a 256-byte internal buffer for normalization. %

| Function | Description
|
| -- > $ fs_size(filename) $ | Returns file size in bytes, or -1 if the file is missing.
| -- > $ fs_read(filename) $ | Reads an entire file into a $ malloc'd $ buffer.
| -- > $ fs_write(filename, data) $ | Overwrites a file with the provided string.
| -- > $ fs_append(filename, data) $ | Appends string data to the end of a file.
| -- > $ fs_delete(filename) $ | Removes a file from the system.
| -- > $ fs_exists(filename) $ | Returns 1 if the file can be opened for reading.

## Advanced Extraction
&& Note: String-based extraction assumes the data is null-terminated. &&

* **fs_count** : Counts occurrences of a specific character in a string buffer.
* **fs_getline** : Retrieves a specific line number from a string (Uses a 512-byte static buffer).
* **fs_readto** : Reads a file from the start up to a specific byte offset.
* **fs_readamount** : Reads a specific chunk of a file defined by start and end bytes.

||
// Reading a specific line from a file
char* content = fs_read("logs.txt");
char* line2 = fs_getline(content, 2); 
// Remember to free(content)!
||

$$ High Priority $$
\\ Functions like $ fs_read $, $ fs_readto $, and $ fs_readamount $ allocate memory dynamically. You MUST call $ free() $ on the returned pointer to avoid memory leaks. \\


---

@@@ Module: SimpleHTTP @@@

# SimpleHTTP Documentation
## Modular Web Server and Client Module

@@@ Feature Overview @@@

`SimpleHTTP` provides a straightforward API for hosting local web servers or making external client requests.
It supports both standard TCP and SSL/HTTPS connections through modular definitions.

-> Cross-Platform: Includes socket shims for Windows ($ winsock2 $) and POSIX ($ sys/socket $).
--> Buffer Control: Uses $ MAX_HTTP_BUF $ (default 65536) for all incoming/outgoing data.

| Module Requirements
|
| -- > $ HTTP_SSL $ : Define to enable HTTPS hosting and SSL termination.
| -- > $ HTTP_CURL $ : Define to enable the $ http_request $ client function.

## Server API
% Lifecycle: Host -> Listen (ReqReady) -> Reply %

| Function | Description
|
| -- > $ http_host(port) $ | Starts a standard HTTP server on the specified port.
| -- > $ http_host_ssl(port, cert, key) $ | Starts an HTTPS server using PEM certificate and key files.
| -- > $ http_reqready() $ | Non-blocking check for new connections; returns 1 if a request is active.
|    | -- > Automatically parses $ method $ and $ path $.
| -- > $ http_reply(html) $ | Sends an HTTP 200 OK response with the provided HTML string.

## Request Handling
&& State Logic: Access request data through the internal $_http_req$ state. &&

* **http_is(path)** : Returns true if the current active request matches the specified path.
* **http_param(key)** : Extracts a URL parameter value (e.g., from "?id=123") into a static buffer.

||
// Simple Server Example
http_host(8080);
while(1) {
    if (http_reqready()) {
        if (http_is("/index")) http_reply("<h1>Welcome</h1>");
        else http_reply("404 Not Found");
    }
}
||

## Client API
\\ Note: Requires $ HTTP_CURL $ to be defined in your project. \\

* **http_request(url)** : Performs a GET request to the target URL and returns the response body.

$$ High Priority $$
\\ The $ http_reply $ function automatically handles closing the client socket and resetting the request state. \\

$$$ Warning!! $$$
&& $ http_param $ and $ http_request $ use static or internal buffers. Copy the data if you need to preserve it across multiple calls. &&


---

@@@ Module: SimpleNet @@@

# SimpleNet Documentation
## Modular Low-Level Networking (TCP/UDP)

@@@ Feature Overview @@@

`SimpleNet` is a lightweight, cross-platform socket wrapper designed for raw data transmission using both TCP and UDP protocols.
It manages an internal state of up to 10 concurrent connections and provides an abstracted interface for both Windows (Winsock2) and POSIX systems.

-> Protocol Support: Supports both $ UDP (0) $ and $ TCP (1) $ modes.
--> Cross-Platform: Handles $ net_close $ and $ net_errno $ shims automatically across platforms.

| Internal State Management
|
| -- > $ _net_fds[10] $ | Array of active socket descriptors.
| -- > $ _net_active[10] $ | Boolean flags tracking which connection IDs are in use.
| -- > $ _net_static_buf $ | Shared 65,536-byte buffer for incoming data.

## Connection API
% Logic: Use unique IDs (0-9) to manage multiple concurrent sockets %

| Function | Description
|
| -- > $ net_host(id, port, proto) $ | Sets up a listener (TCP) or binds a socket (UDP) on the given port.
| -- > $ net_connect(id, host, port, proto) $ | Connects to a remote host.
|    | -- > TCP: Establishes a handshake.
|    | -- > UDP: Prepares the socket for address-based sends.
| -- > $ net_close(id) $ | Terminates the connection and clears the internal state.

## Data Transmission
&& Non-Blocking: `net_read` uses non-blocking flags where available (e.g., $ MSG_DONTWAIT $). &&

* **net_read(id)** : Checks for incoming data. If data exists, returns a pointer to $ _net_static_buf $.
* **net_send(id, data)** : Sends a string to the connected remote peer.
* **net_send_to(id, host, port, data)** : Sends a UDP packet to a specific destination without a persistent connection.

## Metadata & Tracking
\\ Access the last client information through the _last_client[id] structure \\ 

* **net_get_ip(id)** : Returns the IP address of the last sender/client as a string.
* **net_get_port(id)** : Returns the port of the last sender/client as an integer.

||
// Simple UDP Echo Example
net_host(0, 5000, UDP);
while(1) {
    char* msg = net_read(0);
    if (msg) {
        printf("Received: %s from %s\n", msg, net_get_ip(0));
        net_send_to(0, net_get_ip(0), net_get_port(0), "ACK");
    }
}
||

$$ High Priority $$
\\ Ensure that you call $ net_host $ or $ net_connect $ before attempting to read/write to a specific ID index! \\ 

$$$ Warning!! $$$
&& The internal buffer $ _net_static_buf $ is shared across all IDs. If you need to preserve data between consecutive $ net_read $ calls across different IDs, you must copy the data to your own buffer. && 


---

@@@ Module: SimpleParse @@@

# SimpleParse Documentation
## String Extraction and Signature Parsing Module

@@@ Feature Overview @@@

`SimpleParse` is a specialized module for extracting data between markers and identifying function-like signatures within string buffers. It is designed for lightweight scripting or configuration parsing where a full regex engine is overkill.

-> Context Aware: Returns a $ Parsed $ struct containing global offsets, line numbers, and column positions.
--> Structural Parsing: Automatically separates a match into its "Full String", "Signature", and "Inner Content".

| The Parsed Struct
|
| -- > $ int byte $ : Global byte offset in the file.
| -- > $ int lbyte $ : Column offset relative to the start of the line.
| -- > $ int line $ : Current line number.
| -- > $ char fullstr[256] $ : The entire match (e.g., "spawn_player(hero);").
| -- > $ char str[256] $ : The signature (e.g., "spawn_player()").
| -- > $ char con[256] $ : The inner content (e.g., "hero").

## Core Extraction API
% Memory: These functions operate on existing string buffers and do not perform internal heap allocations. %

| Function | Description
|
| -- > $ parsecon(haystack, prefix, suffix) $ | Finds the first occurrence of data between a prefix and suffix.
| -- > $ parseconadv(haystack, prefix, suffix, skip) $ | Same as above, but skips a specified number of matches.
| -- > $ parseline(haystack, line, dest, max) $ | Extracts a specific line of text into a destination buffer.
| -- > $ parselineadv(haystack, line) $ | Returns a $ Parsed $ struct for an entire specific line.

## Logic & Navigation
&& Search: `advparse` is the primary engine for iterating through multiple signatures in one buffer. &&

* **advparse(haystack, skip)** : Scans for the $ Nth $ occurrence of a "prefix(content)suffix" pattern.
* **_sp_get_line_ptr** : Internal helper to jump directly to a specific line number in a buffer.

||
// Advanced Parsing Example
const char* code = "print('hello'); print('world');";
Parsed p = advparse(code, 1); 

// Result for skip 1:
// p.fullstr -> "print('world');"
// p.con     -> "'world'"
// p.line    -> 1
||

$$ High Priority $$
\\ All string fields in the $ Parsed $ struct have a fixed limit of 256 characters. \\

$$$ Warning!! $$$
&& Ensure the $ haystack $ buffer is null-terminated before passing it to any $ SimpleParse $ function to avoid memory overruns. &&


---

@@@ Module: SimpleThreads @@@

# Module: SimpleThreads.h
## Cross-Platform Multi-Threading Library

@@@ Feature Overview @@@

SimpleThreads is a zero-boilerplate, single-header library for C. It abstracts away the differences between Win32 API and POSIX Threads ($ pthreads $) using an ID-based system.

# Functionality
## Thread Management
### Core API

-> Uses a static pool of $ 256 $ thread slots.
--> Automatic return type detection via C11 $ _Generic $.
--> Argument strings are automatically parsed and passed to functions.

| Library Suite
| -- > spawnthread(fn, args, id)
|    | -- > Automatically detects if $ fn $ returns $ int $, $ double $, or $ void* $
|    | -- > Parses $ args $ as a comma-separated string
| -- > getreturn(id)
|    | -- > Blocks until thread completes
|    | -- > Returns a $ void* $ (Must be cast by user)
| -- > isrunning(id)
|    | -- > Returns $ 1 $ if thread is active, $ 0 $ if finished/empty
| -- > killthread(id)
|    | -- > Force terminates a specific slot
| -- > bombthreads()
|    | -- > Nukes all active threads in the pool
| -- > secondsleep(float)
|    | -- > Universal precision sleep ($ seconds $)

## Implementation Example
Launching background tasks and retrieving data:

|| 
   int my_calc(int a, int b) {
       return a + b;
   }

   char* my_name(char* input) {
       return input;
   }

   // Inside main
   spawnthread(my_calc, "10, 20", 0);
   spawnthread(my_name, "\"Ted\"", 1);

   int res = *(int*)getreturn(0);
   char* name = (char*)getreturn(1);
||

## Priority Operations
$$ High Priority $$
\\ Thread results for $ int $ and $ double $ are heap-allocated (boxed). \\
\\ You must call getreturn() to retrieve the data and clear the slot! \\

$$$ Critical Warning $$$
&& Always use an ID between 0 and 255 &&
^ Accessing an ID outside this range will result in no-op or corruption. ^

## Thread Life-Cycle
% Efficiency: Lightweight wrappers around native OS calls %

| Standard Workflow
| -- > Define Function: \\ int my_func(int x) \\
| -- > Spawn: $ spawnthread(my_func, "5", 1) $
|    | -- > Library creates internal $ _st_pkt $
|    | -- > Thread enters $ _st_entry $
| -- > Status Check: $ isrunning(1) $
| -- > Sync: $ getreturn(1) $
|    | -- > Joins thread and retrieves $ _st_results[1] $

## Argument Formatting
If you are referencing a specific return type, use \\ int \\ or \\ void* \\.

-> **Integers**: Pass as standard strings: $ "10, 20, 30" $
-> **Strings**: Wrap internal strings in escaped quotes: $ "\"Hello!\"" $
-> **Empty**: Use an empty string $ "" $ for functions with no parameters.


---

@@@ Module: SimpleTools @@@

# SimpleTools Documentation
## Utility, String, and Time Module

@@@ Feature Overview @@@

`SimpleTools` provides cross-platform utility functions for string manipulation, memory inspection, and time tracking.
It operates independently and includes built-in shims for platform-specific timing. 

-> Cross-Platform: Automatically handles $ usleep $ and $ sleep $ for Windows and POSIX. 
--> Core Buffer: Default $ MAX_HTTP_BUF $ set to 65536. 

| Internal Logic
|
| -- > $ hexdmp(void* ptr, int buflen) $
|    | -- > Prints raw memory in hex format (16 bytes per line). 
|
| -- > $ _str_replace_logic $
|    | -- > The engine behind all string replacement APIs. 

## String Replacement API
% Dynamic Memory: These functions return a $ malloc'd $ string. Always $ free() $ after use! % 

| Function | Description
|
| -- > $ str_replace_first $ | Replaces only the first match found. 
| -- > $ str_replace_all $   | Replaces every occurrence of the target string. 
| -- > $ str_replace_nth $   | Replaces a specific occurrence by index. 
| -- > $ str_replace_count $ | Replaces matches up to a specific count. 
| -- > $ str_replace_range $ | Replaces matches between a start and end index. 

## String Search & Validation
&& Failsafe: Returns 0 (False) if input pointers are NULL. && 

* **str_starts** : Check if string begins with a prefix. 
* **str_ends** : Check if string ends with a suffix. 
* **str_contains** : Standard substring search. 
* **str_is_numeric** : Validates if string consists only of digits. 

## Formatting & Time
\\ Note: str_format uses a static allocation of MAX_HTTP_BUF. \\ 

||
// Formatting Examples
char* s = str_format("User ID: %d", 101); 
str_upper(s); // "USER ID: 101" 
str_trim(s);  // Removes whitespace 
||

^ **Time Tools** ^
* $ time_now() $ : Returns current date/time as "YYYY-MM-DD HH:MM:SS". 
* $ time_unix() $ : Returns raw unix timestamp as a $ long $. 

$$$ JSON Builder $$$
&& use $ json_obj $ to build JSON strings with type-prefixing (s:string, i:int, f:float, b:bool). && 

||
// JSON Example
char* j = json_obj("s:name, i:age, b:active", "Ted", 21, 1); 
// Returns: {"name":"Ted", "age":21, "active":true}
||


---

@@@ Module: SimpleTypes @@@

# Module: simple_types.h
## Arbitrary Precision Arithmetic & Quality of Life Types

@@@ Feature Overview @@@
This header-only library provides fixed-size, stack-allocated large integer and floating-point structures. It leverages C11 $_Generic$ for a unified printing interface and provides basic arithmetic operations for extreme-scale integers.

-> Supports unsigned and signed integers from 32-bit up to 12,288-bit.
--> Built on "limbs" of $u32$ (32-bit segments).
--> Includes basic support for large-mantissa floating point via $ sfloat $.

# Type Definitions
### Base Aliases
typedef uint8_t u8;   typedef uint16_t u16; typedef uint32_t u32; typedef uint64_t u64;
typedef int8_t s8;    typedef int16_t s16;  typedef int32_t s32;  typedef int64_t s64;

### Large Structures
Generated via the $DEF_STRUCTS(BITS, LIMBS)$ macro:
| -- > suintBITS: struct { u32 limbs[LIMBS]; }
| -- > sintBITS: struct { s32 limbs[LIMBS]; }
| -- > sfloatBITS: struct { suintBITS mantissa; s32 exponent; }

## Bit-Width Options
Pre-defined via DEF_STRUCTS for:
% 32 (1 limb), 64 (2 limbs), 128 (4 limbs), 256 (8 limbs), 512 (16 limbs), 1024 (32 limbs), 2048 (64 limbs), 4096 (128 limbs), 8192 (256 limbs), 12288 (384 limbs) %

@@@ Core Functions @@@

## Printing & Output
The library uses $ slibprint $ and $ slibnfprint $ via C11 _Generic selection.

| Output Styles
| -- > $ slibprint(val) $: Formatted decimal output.
|    | -- > Calls _internal_dec_ascii.
|    | -- > Signed types: Prints "-" if limbs[COUNT-1] < 0.
|    | -- > Float types: Prints mantissa decimal then " * 2^exponent".
|    | -- > Includes thousands separators (e.g., 1,000,000).
| -- > $ slibnfprint(val) $: "No-format" raw hex output.
|    | -- > Calls _internal_raw_hex (prepends 0x).

## Arithmetic Operations
Focused on the 12288-bit (384 limb) implementations.

| Operations
| -- > $ suint12288_add(res, a, b) $: 
|    | -- > sum = (u64)a.limbs[i] + b.limbs[i] + carry. Returns final u32 carry.
| -- > $ suint12288_mul(res, a, b) $: 
|    | -- > Full multiplication loop; skips if a.limbs[i] == 0.
| -- > $ suint12288_pow(res, base_val, exp) $: 
|    | -- > Iterative multiplication; takes u32 exp.
| -- > $ suint12288_tetrate(res, base, height) $: 
|    | -- > Uses suint12288_pow iteratively.

$$High Priority$$
\\ Note: suint12288_tetrate uses current_val.limbs[0] as the exponent for the next layer. \\
^ This truncates the exponent to 32-bits during tetration. ^

@@@ Logical Flow @@@

## Bit Shifting
Defined via $DEF_SHIFT(BITS, COUNT)$ macro.

| Shift Mechanism
| -- > If shift >= total bits: memset 0 and return.
| -- > Carry-over logic: v->limbs[i] = v->limbs[i - limb_shift] << bit_shift;
| -- > v->limbs[i] |= v->limbs[i - limb_shift - 1] >> (32 - bit_shift);

$$$Critical Warning$$$
&& Shifting by a negative value or 0 returns immediately without modification. &&

## Internal Mechanics
% Memory: _internal_dec_ascii uses local u32 temp[count] and memcpy. %
% Buffer: char digits[5000] used for division-by-10 result extraction. %

## Example Usage
||
    // 1. Declare and Initialize to Zero
    suint12288 big_val; 
    memset(&big_val, 0, sizeof(big_val));

    // 2. Assign and Manipulate
    big_val.limbs[0] = 1;
    suint12288_shl(&big_val, 12000); // 2^12000

    // 3. Print Results
    printf("Decimal Value: ");
    slibprint(big_val); 
||


---
